# Exedeck Expansion Plan (Herd-Style + Node Support)

## Goal

Expand Exedeck from a task runner into a project manager that can:

- Provision new projects in the background (for example, `laravel new app`)
- Manage site-like project runtimes
- Add routing/proxy capabilities similar to Herd
- Add monitoring for logs, queues, mail, and process health

## Practicality Snapshot

This is practical with the current architecture. Exedeck already has:

- Persisted `projects/tasks` config
- Long-lived process management
- Task output streaming and buffered logs
- CPU/memory polling

These pieces make a project provisioning and monitoring layer a natural extension.

## Phased Plan

### Phase 1: Project Runtime Model (Low Risk, High Leverage)

Introduce schema v3 and add project metadata:

- `project.kind`: `laravel | node | custom`
- `project.services`: descriptors for web, queue, scheduler, mail, db
- Backward-compatible migration from current schema

Keep existing tasks, but support task templates generated by project type.

### Phase 2: Background Jobs for Provisioning (Core Capability)

Add a one-off `jobManager` in Electron main process for background provisioning jobs:

- IPC:
  - `project:create`
  - `project:create:status`
  - `project:create:cancel`
  - `project:detect`
- Stream provisioning logs and progress to renderer
- Persist job history/summary for troubleshooting

Provisioner examples:

- Laravel:
  - Primary: `laravel new <name>`
  - Fallback: Composer-based flow
- Node:
  - `npm create vite@latest` or selected template commands

### Phase 3: Detection + Templates

Add project detection rules and starter task templates.

Detection:

- Laravel: detect `artisan` and `composer.json`
- Node: detect `package.json`

Template tasks:

- Laravel:
  - `php artisan serve`
  - `php artisan queue:work`
  - `npm run dev`
- Node:
  - `npm run dev`
  - optional worker commands

### Phase 4: Site Routing/Proxy Layer

Add a routing provider abstraction with three paths:

- Option A: External Nginx/Caddy provider
- Option B: Built-in internal reverse proxy (Node process)
- Option C: Support both via provider interface

Recommended sequence:

1. Start with internal proxy for portability/speed
2. Add Nginx provider for Herd-like parity

### Phase 5: Monitoring

Layer monitoring over project/services:

- Stage 1:
  - Process health, CPU/memory, task logs
- Stage 2:
  - Structured log watchers
  - Queue health probes
  - Mail service health
- Stage 3:
  - Dedicated project observability panels
  - Error summaries and quick diagnostics

### Phase 6: UX Evolution

Update onboarding/settings from manual task entry toward:

- "Create Project" wizard
- Stack selection (Laravel/Node/Custom)
- Provisioning options
- Optional default services/templates

Keep advanced manual task editing for power users.

## Expansion Tracks

### Track A: Lean (2-4 weeks)

- Schema v3
- Background provisioning jobs
- Project detection/templates
- Internal proxy foundation

Best for quick momentum and user validation.

### Track B: Herd Parity (6-10+ weeks)

Includes Track A plus:

- Nginx provider
- Domain management and reload workflows
- Deeper Laravel-specific monitoring

Best for direct competitive positioning.

### Track C: Plugin Architecture (Long-Term)

Provider/plugin interfaces for:

- Project detectors
- Provisioners
- Task templates
- Monitoring adapters

Best for extending beyond Laravel/Node over time.

## Risks and Constraints

- Cross-platform shell/process behavior differences
- External dependency assumptions (`laravel`, `composer`, `npm/pnpm`)
- Nginx/Caddy integration complexity (permissions, safe reloads, validation)

## Recommended First Implementation Slice

Implement this first:

1. Config schema v3 with `project.kind` and `services`
2. `jobManager` for one-off background jobs
3. `project:create` IPC to run Laravel/Node project scaffolding
4. Minimal UI for "Create Project in Background" with live logs/status

Then add detection/templates as step two.

